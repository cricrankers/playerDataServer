/ Map to store URL responses
const urlResponseMap = new Map();

// Pre-fetch responses and store them in the map
document.addEventListener('DOMContentLoaded', async () => {
    const urlList = Array.from(document.querySelectorAll('.url-input'));

    for (const urlElement of urlList) {
        const url = urlElement.value;
        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;

        try {
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            console.log("response mila")
            const data = await response.json();
            urlResponseMap.set(url, data.contents);
        } catch (error) {
            console.log("response nahi mila")
            urlResponseMap.set(url, { error: error.message }); // Handle errors gracefully
        }
    }
});

// Scrap function that uses the cached response or fetches if not available
async function scrap(rowNo, sectionId) {
    scrapEngineTable(sectionId);
    const section = document.getElementById(sectionId);
    const url = section.querySelector('.url-input').value;
    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
    const tableContainer = document.getElementById('table-container');

    tableContainer.innerHTML = '<p>Data is loading...</p>';

    let html;

    try {
        // Use the cached response if available
        if (urlResponseMap.has(url) && urlResponseMap.get(url) !== undefined) {
            console.log('already h cached')
            html = urlResponseMap.get(url);
        } else {
            console.log("cached nahi h")
            // Fetch new data if not in the map
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const data = await response.json();
            html = data.contents;

            // Cache the new response
            urlResponseMap.set(url, html);
        }

        const doc = new DOMParser().parseFromString(html, 'text/html');

        // Reference only
        const playerUrl = doc.querySelector('.icc-home');
        const playerUrlBox = document.getElementById('playerUrl');
        playerUrlBox.innerText = playerUrl?.getElementsByTagName('a')[0]?.innerText || 'N/A';

        const tables = doc.querySelectorAll('table.engineTable');

        let careerAveragesTable = Array.from(tables).find((table) =>
            table.querySelector('caption')?.innerText.trim() === 'Career averages'
        );

        if (careerAveragesTable) {
            const rows = careerAveragesTable.querySelectorAll('tr');
            const filteredRow = rows[rowNo];

            if (filteredRow) {
                const columns = filteredRow.querySelectorAll('td');
                const populateField = (selector, value) => {
                    try {
                        section.querySelector(selector).value = value;
                    } catch (error) {
                        // Ignore errors when populating fields
                    }
                };

                populateField('#debut', columns[1]?.innerText.trim().split('-')[0]);
                populateField('#last-played', columns[1]?.innerText.trim().split('-')[1]);
                populateField('#matches', columns[2]?.innerText.trim());
                populateField('#innings', columns[3]?.innerText.trim());
                populateField('#runs', columns[5]?.innerText.trim());
                populateField('#average', columns[7]?.innerText.trim());
                populateField('#strikeRate', columns[9]?.innerText.trim());
                populateField('#fifties', columns[11]?.innerText.trim());
                populateField('#hundreds', columns[10]?.innerText.trim());

                careerAveragesTable = renderTable(careerAveragesTable);
                tableContainer.innerHTML = careerAveragesTable.outerHTML;
            } else {
                tableContainer.innerHTML = '<p>Filtered row not found!</p>';
            }
        } else {
            tableContainer.innerHTML = '<p>Career Averages Table not found!</p>';
        }
    } catch (error) {
        tableContainer.innerHTML = `<p>Error: ${error.message}</p>`;
    }
}

async function scrapYear(rowNo, sectionId) {
    scrapEngineTable(sectionId);
    const section = document.getElementById(sectionId);
    const url = section.querySelector('.url-input').value;
    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
    const tableContainer = document.getElementById('table-container');

    tableContainer.innerHTML = '<p>Data is loading...</p>'; // Loading message

    try {
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        const html = data.contents;
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const tables = doc.querySelectorAll('table.engineTable');

        let careerAveragesTable = Array.from(tables).find((table) =>
            table.querySelector('caption')?.innerText.trim() === 'Career averages'
        );

        if (careerAveragesTable) {
            const rows = careerAveragesTable.querySelectorAll('tr');
            const filteredRow = rows[rowNo];

            if (filteredRow) {
                const columns = filteredRow.querySelectorAll('td');
                const populateField = (selector, value) => {
                    try {
                        section.querySelector(selector).value = value;
                    } catch (error) {
                    }
                };

                populateField('#debut', columns[1]?.innerText.trim().split('-')[0]);
                populateField('#last-played', columns[1]?.innerText.trim().split('-')[1]);
                populateField('#matches', columns[1]?.innerText.trim());
                populateField('#innings', columns[2]?.innerText.trim());
                populateField('#runs', columns[4]?.innerText.trim());
                populateField('#average', columns[6]?.innerText.trim());
                populateField('#strikeRate', columns[8]?.innerText.trim());
                populateField('#fifties', columns[10]?.innerText.trim());
                populateField('#hundreds', columns[9]?.innerText.trim());

                careerAveragesTable = renderTable(careerAveragesTable);
                tableContainer.innerHTML = careerAveragesTable.outerHTML;
            } else {
                tableContainer.innerHTML = '<p>Filtered row not found!</p>';
            }
        } else {
            tableContainer.innerHTML = '<p>Career Averages Table not found!</p>';
        }
    } catch (error) {
        console.error('Error fetching or parsing HTML:', error);
        tableContainer.innerHTML = `<p>Error: ${error.message}</p>`;
    }
}

















// Map to store URL responses
const urlResponseMap = new Map();

// Prefetch all URLs on DOMContentLoaded
document.addEventListener('DOMContentLoaded', async () => {
    const urlList = Array.from(document.querySelectorAll('.url-input'));
     console.log(urlList.length)
    for (const urlElement of urlList) {
        const url = urlElement.value;
        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;

        // Skip fetching if the URL is already in the map
        if (urlResponseMap.has(url)) continue;

        try {
            // Wait for the current fetch to resolve or reject before proceeding
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            console.log('mila')
            const data = await response.json();
            urlResponseMap.set(url, data.contents);
        } catch (error) {
            console.log(' nahi mila')
            // Handle errors gracefully by storing the error in the map
            urlResponseMap.set(url, { error: error.message });
        }
    }
});


// Function to add new URLs from a specific section
async function addUrlsFromSection(sectionId) {
    const section = document.getElementById(sectionId);
    const urlList = Array.from(section.querySelectorAll('.url-input'));

    for (const urlElement of urlList) {
        const url = urlElement.value;
        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;

        // Skip fetching if the URL is already in the map
        if (urlResponseMap.has(url)) continue;

        try {
            console.log('mila')
            // Wait for the current URL request to resolve or reject before proceeding
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const data = await response.json();
            urlResponseMap.set(url, data.contents);
        } catch (error) {
            console.log('nahi mila')
            // Handle errors gracefully by storing the error in the map
            urlResponseMap.set(url, { error: error.message });
        }
    }
}


// Scrap function that uses the cached response or fetches if not available
async function scrap(rowNo, sectionId) {
    scrapEngineTable(sectionId);
    const section = document.getElementById(sectionId);
    const url = section.querySelector('.url-input').value;
    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
    const tableContainer = document.getElementById('table-container');

    tableContainer.innerHTML = '<p>Data is loading...</p>';

    let html;

    try {
        // Use the cached response if available
        if (urlResponseMap.has(url) && urlResponseMap.get(url) !== undefined) {
            console.log('pehle se hai')
            html = urlResponseMap.get(url);
        } else {
            // Fetch new data if not in the map
            console.log('pehle se nahi h , req kri h')
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const data = await response.json();
            html = data.contents;

            // Cache the new response
            urlResponseMap.set(url, html);
        }

        const doc = new DOMParser().parseFromString(html, 'text/html');

        // Reference only
        const playerUrl = doc.querySelector('.icc-home');
        const playerUrlBox = document.getElementById('playerUrl');
        playerUrlBox.innerText = playerUrl?.getElementsByTagName('a')[0]?.innerText || 'N/A';

        const tables = doc.querySelectorAll('table.engineTable');

        let careerAveragesTable = Array.from(tables).find((table) =>
            table.querySelector('caption')?.innerText.trim() === 'Career averages'
        );

        if (careerAveragesTable) {
            const rows = careerAveragesTable.querySelectorAll('tr');
            const filteredRow = rows[rowNo];

            if (filteredRow) {
                const columns = filteredRow.querySelectorAll('td');
                const populateField = (selector, value) => {
                    try {
                        section.querySelector(selector).value = value;
                    } catch (error) {
                        // Ignore errors when populating fields
                    }
                };

                populateField('#debut', columns[1]?.innerText.trim().split('-')[0]);
                populateField('#last-played', columns[1]?.innerText.trim().split('-')[1]);
                populateField('#matches', columns[2]?.innerText.trim());
                populateField('#innings', columns[3]?.innerText.trim());
                populateField('#runs', columns[5]?.innerText.trim());
                populateField('#average', columns[7]?.innerText.trim());
                populateField('#strikeRate', columns[9]?.innerText.trim());
                populateField('#fifties', columns[11]?.innerText.trim());
                populateField('#hundreds', columns[10]?.innerText.trim());

                careerAveragesTable = renderTable(careerAveragesTable);
                tableContainer.innerHTML = careerAveragesTable.outerHTML;
            } else {
                tableContainer.innerHTML = '<p>Filtered row not found!</p>';
            }
        } else {
            tableContainer.innerHTML = '<p>Career Averages Table not found!</p>';
        }
    } catch (error) {
        tableContainer.innerHTML = `<p>Error: ${error.message}</p>`;
    }
}


async function scrapYear(rowNo, sectionId) {
    scrapEngineTable(sectionId);
    const section = document.getElementById(sectionId);
    const url = section.querySelector('.url-input').value;
    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
    const tableContainer = document.getElementById('table-container');

    tableContainer.innerHTML = '<p>Data is loading...</p>'; // Loading message

    let html;

    try {
        // Use the cached response if available
        if (urlResponseMap.has(url) && urlResponseMap.get(url) !== undefined) {
            html = urlResponseMap.get(url);
        } else {
            // Fetch new data if not in the map
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const data = await response.json();
            html = data.contents;

            // Cache the new response
            urlResponseMap.set(url, html);
        }

        const doc = new DOMParser().parseFromString(html, 'text/html');
        const tables = doc.querySelectorAll('table.engineTable');

        let careerAveragesTable = Array.from(tables).find((table) =>
            table.querySelector('caption')?.innerText.trim() === 'Career averages'
        );

        if (careerAveragesTable) {
            const rows = careerAveragesTable.querySelectorAll('tr');
            const filteredRow = rows[rowNo];

            if (filteredRow) {
                const columns = filteredRow.querySelectorAll('td');
                const populateField = (selector, value) => {
                    try {
                        section.querySelector(selector).value = value;
                    } catch (error) {
                        // Ignore errors when populating fields
                    }
                };

                populateField('#debut', columns[1]?.innerText.trim().split('-')[0]);
                populateField('#last-played', columns[1]?.innerText.trim().split('-')[1]);
                populateField('#matches', columns[1]?.innerText.trim());
                populateField('#innings', columns[2]?.innerText.trim());
                populateField('#runs', columns[4]?.innerText.trim());
                populateField('#average', columns[6]?.innerText.trim());
                populateField('#strikeRate', columns[8]?.innerText.trim());
                populateField('#fifties', columns[10]?.innerText.trim());
                populateField('#hundreds', columns[9]?.innerText.trim());

                careerAveragesTable = renderTable(careerAveragesTable);
                tableContainer.innerHTML = careerAveragesTable.outerHTML;
            } else {
                tableContainer.innerHTML = '<p>Filtered row not found!</p>';
            }
        } else {
            tableContainer.innerHTML = '<p>Career Averages Table not found!</p>';
        }
    } catch (error) {
        tableContainer.innerHTML = `<p>Error: ${error.message}</p>`;
    }
}



/// filter table 
// ---------------------------- Fetch and Display Engine Table ---------------------------- //

/**
 * Fetches and displays the additional engine table alongside the Career Averages table.
 */

async function scrapEngineTable(sectionId) {
    const section = document.getElementById(sectionId);
    const url = section.querySelector('.url-input').value;
    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
    const tableContainer = document.getElementById('table-container2');

    tableContainer.innerHTML = '<p>Data is loading...</p>'; // Loading message

    try {
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        const html = data.contents;
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const tables = doc.querySelectorAll('table.engineTable');

        // Find the table based on specific text contents (e.g., "Records type", "View", "Ordered by")
        const engineTable = Array.from(tables).find((table) => {
            const rows = table.querySelectorAll('tr');
            return Array.from(rows).some((row) => {
                const cellText = row.textContent.trim();
                return cellText.includes('Records type') || cellText.includes('View') || cellText.includes('Ordered by');
            });
        });

        if (engineTable) {
            const tableHtml = engineTable.outerHTML;
            tableContainer.innerHTML = tableHtml; // Display the fetched table
        } else {
            tableContainer.innerHTML = '<p>Engine Table not found!</p>';
        }
    } catch (error) {
        console.error('Error fetching or parsing Engine Table HTML:', error);
        tableContainer.innerHTML = `<p>Error: ${error.message}</p>`;
    }
}





































// Map to store URL responses
const urlResponseMap = new Map();

// Prefetch all URLs on DOMContentLoaded
document.addEventListener('DOMContentLoaded', async () => {
    const urlList = Array.from(document.querySelectorAll('.url-input'));
     console.log(urlList.length)
    for (const urlElement of urlList) {
        const url = urlElement.value;
        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;

        // Skip fetching if the URL is already in the map
        if (urlResponseMap.has(url)) continue;

        try {
            // Wait for the current fetch to resolve or reject before proceeding
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            console.log('mila')
            const data = await response.json();
            urlResponseMap.set(url, data.contents);
        } catch (error) {
            console.log(' nahi mila')
            // Handle errors gracefully by storing the error in the map
            urlResponseMap.set(url, { error: error.message });
        }
    }
});


// Function to add new URLs from a specific section
async function addUrlsFromSection(sectionId) {
    const section = document.getElementById(sectionId);
    const urlList = Array.from(section.querySelectorAll('.url-input'));

    for (const urlElement of urlList) {
        const url = urlElement.value;
        const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;

        // Skip fetching if the URL is already in the map
        if (urlResponseMap.has(url)) continue;

        try {
            console.log('mila')
            // Wait for the current URL request to resolve or reject before proceeding
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const data = await response.json();
            urlResponseMap.set(url, data.contents);
        } catch (error) {
            console.log('nahi mila')
            // Handle errors gracefully by storing the error in the map
            urlResponseMap.set(url, { error: error.message });
        }
    }
}


// Scrap function that uses the cached response or fetches if not available
async function scrap(rowNo, sectionId) {
    scrapEngineTable(sectionId);
    const section = document.getElementById(sectionId);
    const url = section.querySelector('.url-input').value;
    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
    const tableContainer = document.getElementById('table-container');

    tableContainer.innerHTML = '<p>Data is loading...</p>';

    let html;

    try {
        // Use the cached response if available
        if (urlResponseMap.has(url) && urlResponseMap.get(url) !== undefined) {
            console.log('pehle se hai')
            html = urlResponseMap.get(url);
        } else {
            // Fetch new data if not in the map
            console.log('pehle se nahi h , req kri h')
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const data = await response.json();
            html = data.contents;

            // Cache the new response
            urlResponseMap.set(url, html);
        }

        const doc = new DOMParser().parseFromString(html, 'text/html');

        // Reference only
        const playerUrl = doc.querySelector('.icc-home');
        const playerUrlBox = document.getElementById('playerUrl');
        playerUrlBox.innerText = playerUrl?.getElementsByTagName('a')[0]?.innerText || 'N/A';

        const tables = doc.querySelectorAll('table.engineTable');

        let careerAveragesTable = Array.from(tables).find((table) =>
            table.querySelector('caption')?.innerText.trim() === 'Career averages'
        );

        if (careerAveragesTable) {
            const rows = careerAveragesTable.querySelectorAll('tr');
            const filteredRow = rows[rowNo];

            if (filteredRow) {
                const columns = filteredRow.querySelectorAll('td');
                const populateField = (selector, value) => {
                    try {
                        section.querySelector(selector).value = value;
                    } catch (error) {
                        // Ignore errors when populating fields
                    }
                };

                populateField('#debut', columns[1]?.innerText.trim().split('-')[0]);
                populateField('#last-played', columns[1]?.innerText.trim().split('-')[1]);
                populateField('#matches', columns[2]?.innerText.trim());
                populateField('#innings', columns[3]?.innerText.trim());
                populateField('#runs', columns[5]?.innerText.trim());
                populateField('#average', columns[7]?.innerText.trim());
                populateField('#strikeRate', columns[9]?.innerText.trim());
                populateField('#fifties', columns[11]?.innerText.trim());
                populateField('#hundreds', columns[10]?.innerText.trim());

                careerAveragesTable = renderTable(careerAveragesTable);
                tableContainer.innerHTML = careerAveragesTable.outerHTML;
            } else {
                tableContainer.innerHTML = '<p>Filtered row not found!</p>';
            }
        } else {
            tableContainer.innerHTML = '<p>Career Averages Table not found!</p>';
        }
    } catch (error) {
        tableContainer.innerHTML = `<p>Error: ${error.message}</p>`;
    }
}


async function scrapYear(rowNo, sectionId) {
    scrapEngineTable(sectionId);
    const section = document.getElementById(sectionId);
    const url = section.querySelector('.url-input').value;
    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
    const tableContainer = document.getElementById('table-container');

    tableContainer.innerHTML = '<p>Data is loading...</p>'; // Loading message

    let html;

    try {
        // Use the cached response if available
        if (urlResponseMap.has(url) && urlResponseMap.get(url) !== undefined) {
            html = urlResponseMap.get(url);
        } else {
            // Fetch new data if not in the map
            const response = await fetch(proxyUrl);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

            const data = await response.json();
            html = data.contents;

            // Cache the new response
            urlResponseMap.set(url, html);
        }

        const doc = new DOMParser().parseFromString(html, 'text/html');
        const tables = doc.querySelectorAll('table.engineTable');

        let careerAveragesTable = Array.from(tables).find((table) =>
            table.querySelector('caption')?.innerText.trim() === 'Career averages'
        );

        if (careerAveragesTable) {
            const rows = careerAveragesTable.querySelectorAll('tr');
            const filteredRow = rows[rowNo];

            if (filteredRow) {
                const columns = filteredRow.querySelectorAll('td');
                const populateField = (selector, value) => {
                    try {
                        section.querySelector(selector).value = value;
                    } catch (error) {
                        // Ignore errors when populating fields
                    }
                };

                populateField('#debut', columns[1]?.innerText.trim().split('-')[0]);
                populateField('#last-played', columns[1]?.innerText.trim().split('-')[1]);
                populateField('#matches', columns[1]?.innerText.trim());
                populateField('#innings', columns[2]?.innerText.trim());
                populateField('#runs', columns[4]?.innerText.trim());
                populateField('#average', columns[6]?.innerText.trim());
                populateField('#strikeRate', columns[8]?.innerText.trim());
                populateField('#fifties', columns[10]?.innerText.trim());
                populateField('#hundreds', columns[9]?.innerText.trim());

                careerAveragesTable = renderTable(careerAveragesTable);
                tableContainer.innerHTML = careerAveragesTable.outerHTML;
            } else {
                tableContainer.innerHTML = '<p>Filtered row not found!</p>';
            }
        } else {
            tableContainer.innerHTML = '<p>Career Averages Table not found!</p>';
        }
    } catch (error) {
        tableContainer.innerHTML = `<p>Error: ${error.message}</p>`;
    }
}



/// filter table 
// ---------------------------- Fetch and Display Engine Table ---------------------------- //

/**
 * Fetches and displays the additional engine table alongside the Career Averages table.
 */

async function scrapEngineTable(sectionId) {
    const section = document.getElementById(sectionId);
    const url = section.querySelector('.url-input').value;
    const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`;
    const tableContainer = document.getElementById('table-container2');

    tableContainer.innerHTML = '<p>Data is loading...</p>'; // Loading message

    try {
        const response = await fetch(proxyUrl);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        const html = data.contents;
        const doc = new DOMParser().parseFromString(html, 'text/html');
        const tables = doc.querySelectorAll('table.engineTable');

        // Find the table based on specific text contents (e.g., "Records type", "View", "Ordered by")
        const engineTable = Array.from(tables).find((table) => {
            const rows = table.querySelectorAll('tr');
            return Array.from(rows).some((row) => {
                const cellText = row.textContent.trim();
                return cellText.includes('Records type') || cellText.includes('View') || cellText.includes('Ordered by');
            });
        });

        if (engineTable) {
            const tableHtml = engineTable.outerHTML;
            tableContainer.innerHTML = tableHtml; // Display the fetched table
        } else {
            tableContainer.innerHTML = '<p>Engine Table not found!</p>';
        }
    } catch (error) {
        console.error('Error fetching or parsing Engine Table HTML:', error);
        tableContainer.innerHTML = `<p>Error: ${error.message}</p>`;
    }
}